\documentclass[a4paper,12pt]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{cmap}					
\usepackage[T2A]{fontenc}			
\usepackage[utf8]{inputenc}			
\usepackage[english,russian]{babel}	

\usepackage{multicol}
\setlength{\columnsep}{1cm}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{defn}[theorem]{Определение}

\newtheorem{theorem_1}{Theorem}[section]
\newtheorem{statement}[theorem_1]{Утверждение}


\author{Алексей Козловский}
\title{Заметки по сверточным нейронным сетям}
\date{\today}

\begin{document}
    

\maketitle




\section{Основные математические понятия}%
\label{sec:основные_математические_понятия}

\subsection{Свертка сигналов}%
\label{sub:свертка_сигналов}

\begin{defn}
    Свертка (в математике) - это мера перекрывания одной функции с отраженной и сдвинутой копией другой. В дискретном случае имеем 
     \[
         y(t) = x(t) (*) h(t) = \sum_{n=-\infty}^{\infty} x(\tau)h(t - \tau)
    .\] 
    В непрерывном случае свертка двух функций записывается в виде:
    \[
        y(t) = x(t) (*) h(t) = \int_{\tau = -\infty}^{\infty } x(\tau)h(t - \tau)
    .\] 
\end{defn}
В общем случае любую величину, испытывающую изменения во времени и/или пространстве
можно рассматривать как сигнал. Сигналы могуть быть аналоговыми и цифровыми.
Мы будем работать с цифровыми сигналами, так как используем вычислительную технику,
которая работает дискретно. Поэтому, нам придется переводить аналоговый сигнал
в цифровой.
\begin{defn}
    Семплирование (sampling) - замерение апмлитуды сигнала через определенные 
    пространственные или временные интервалы фиксированной величины.
\end{defn}
\begin{defn}
   Квантование - разбиение диапазона отсчетных значений сигнала на конечное число
   уровней и округление этих значений до ближайших уровней
\end{defn}

В итоге семплирования мы получаем счётное множество значений сигнала, но значения
его элементов могут принадлежать несчётному множеству, например $\mathbb{R}$. 
Поэтому следует применить квантование, чтобы эти элементы стали тоже принадлежать
счетному множеству. Ну и так как наши множества изначально ограничены сверху и снизу
и мы сделали их счетными, то теперь мы можем хранить информацию о сигнале.

После применения семплирования к аналоговому сигналу получается \textbf{дискретный}
сигнал.

После применения квантования к дискретному сигналу получается \textbf{цифровой}
сигнал.

\begin{defn}
    Двумерная единичная дельта функция $\delta(n_1, n_2)$, где $n_1$ и $n_2$ - 
    координаты горизонтали и вертикали определяется следующим образом: 
    $\delta(0, 0) = 1$, во всех остальных случаях $\delta(n_1, n_2) = 0$.
\end{defn}
\begin{defn}
    Смещенная единичная дельта функция $\delta(n_1 - k_1, n_2 - k_2)$ определяется
    следующим образом: $\delta(n_1 - k_1, n_2 - k_2) = 0$ только если $n_1 = k_1$ и
     $n_2 = k_2$.
\end{defn}

\begin{statement}
    Любой двумерный дискретный сигнал можно представить в виде взвешенной суммы
    единичной дельта-функции с различными координатами.
\end{statement}

\subsection{Часто используемые фильтры изображений}%
\label{sub:часто_используемые_фильтры_изображений}
\begin{defn}
    Усредняющий фильтра (mean filter) - низкочастотный, фильтр, вычисляющий
    скользящее среднее интенсивности пискелей в любой заданной точке.
    $$\begin{pmatrix}
    \frac{1}{9} & \frac{1}{9} & \frac{1}{9} \\
    \frac{1}{9} & \frac{1}{9} & \frac{1}{9} \\
    \frac{1}{9} & \frac{1}{9} & \frac{1}{9} \\
\end{pmatrix}$$
\end{defn}
Усредняющий фильтр используется главным образом для снижения шума на изображении.

\begin{defn}
    Медианный фильтр (median filter) - заменяет каждый пиксель медианным значением
    интенсивности пикселей в его окрестности, покрываемой ядром фильтра.
\end{defn}
Медианный фильтр хорошо подходит для удаления черно-белого крапчатого шума.

\begin{defn}
    Гауссовский фильтра - это видоизменённая версия медианного фильтра, в которой
    веса функции импульсного отклика распределены по нормальному закону относительно начала
    координат.
\end{defn}

\begin{defn}
    Горизонтальный градиентный фильтр - фильтр, применяя который можно посчитать 
    градиент по $x$. 
    $$
    \begin{pmatrix}
    0 & 0 & 0 \\
    0 & 1 & -1 \\
    0 & 0 & 0 \\
    \end{pmatrix}, 
\begin{pmatrix}
    0 & 0 & 0 \\
    1 & 0 & -1 \\
    0 & 0 & 0 \\
\end{pmatrix}$$
\end{defn}

\begin{defn}
    Вертикальный градиентный фильтр - фильтр, применяя который можно посчитать
    градиент по $y$.
$$ \begin{pmatrix}
    0 & -1 & 0 \\
    0 & 1 & 0 \\
    0 & 0 & 0 \\
\end{pmatrix}, 
\begin{pmatrix}
    0 & -1 & 0 \\
    0 & 0 & 0 \\
    0 & 1 & 0 \\
\end{pmatrix}
$$
\end{defn}

\begin{defn}
    Фильтр Собеля - градиентный фильтр (может быть как горизонтальным, так и 
    вертикальным), который учитывает градиент не только в текущий точке, но и
    градиент в сосдених точках.
    $$H_x = \begin{pmatrix}
    1 & 0 & -1 \\
    2 & 0 & -2 \\
    1 & 0 & -1 \\
\end{pmatrix}$$
$$ H_y = \begin{pmatrix}
    -1 & -2 & -1 \\
    0 & 0 & 0 \\
    1 & 2 & 1 \\
\end{pmatrix}
$$
\end{defn}

Фильтры Собеля высокочастотны, так как ослабляют низкочастотные компоненты.
Их используют для обнаружения краев на изображении.

\begin{defn}
    Фильтр тождественного преобразования - не меняет изображение.
$$\begin{pmatrix}
    0 & 0 & 0 \\
    0 & 1 & 0 \\
    0 & 0 & 0 \\
\end{pmatrix}$$
\end{defn}


\section{Сверточные нейронные сети}%
\begin{defn}
    Сверточные нейронные сети - нейронные сети, базирующиеся на свертке изображений
    и обнаружении особенностей на основе фильтров, которым обучается CNN.
\end{defn}

\subsection{Компоненты CNN}%
\label{sub:компоненты_cnn}

Компоненты CNN:
\begin{itemize}
    \item \textbf{Входной слой}. Используется для хранения интенсивности пикселей
        изображения
\end{itemize}
\begin{itemize}
    \item \textbf{Слой свертки}. Принимает изображения от предыдущих слоев
        и выполняет их свертку с определенным количеством фильтров для создания 
        изображений, называемых \textit{выходными картами признаков}. Количество 
        выходных карт признаков = количеству фильтров.
\end{itemize}
\begin{itemize}
    \item \textbf{Слой активации}. Например ReLU. Добавляет в сеть нелинейность.
\end{itemize}
\begin{itemize}
    \item \textbf{Слой субдискретизации (пулинга)}. Выполняет снижение размерности
        карт признаков по высоте и ширине (глубина не меняется!).
\end{itemize}
\begin{itemize}
    \item \textbf{Полносвязные слои}. Обычные полносвязные слои (многослойный
        персептрон).
\end{itemize}

\end{document}

